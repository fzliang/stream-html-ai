<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>增量 HTML 渲染示例</title>
  <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
  <style>
    /* 保留必要的自定义样式 */
    .log-entry.info {
      border-left-color: #3b82f6;
    }
    .log-entry.success {
      border-left-color: #10b981;
    }
    .log-entry.warning {
      border-left-color: #f59e0b;
    }
    .log-entry.error {
      border-left-color: #ef4444;
    }

    #app .min-h-screen {
      height: 100%;
    }
    
    /* 预览区域动画 - 为所有属性变更添加平滑过渡 */
    #app * {
      transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, 
                          opacity, box-shadow, transform, filter, backdrop-filter,
                          width, height, padding, margin, border-width, border-radius,
                          font-size, font-weight, line-height, letter-spacing,
                          top, right, bottom, left, translate, scale, rotate;
      transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
      transition-duration: 300ms;
    }
    
    /* 文本内容变化不需要动画 */
    #app *::before,
    #app *::after {
      transition: none;
    }
    
    /* 新增元素飞入动画 - 通过 JavaScript 动态添加，这里只定义动画效果 */
    @keyframes slideInFromRight {
      from {
        opacity: 0;
        transform: translateX(600px);
      }
      to {
        opacity: 1;
        transform: translateX(0);
      }
    }
    
    /* 为带有 animate-in 类的元素添加飞入动画 */
    #app .animate-in {
      animation: slideInFromRight 1s cubic-bezier(0.4, 0, 0.2, 1) forwards;
    }
  </style>
</head>
<body class="flex gap-5 p-5 h-screen overflow-hidden bg-gray-50">
  <!-- 左侧面板 -->
  <div class="flex-1 flex flex-col min-w-0">
    <h1 class="text-3xl font-bold text-gray-800 mb-5">增量 HTML 渲染演示</h1>
    
    <!-- 控制按钮组 -->
    <div class="flex flex-wrap gap-2 mb-5">
      <button onclick="demo1()" class="px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors font-medium">
        示例: 基础渲染
      </button>
      <!-- <button onclick="demo2()" class="px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors font-medium">
        示例: 流式文本
      </button>
      <button onclick="demo3()" class="px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors font-medium">
        示例: 动态表单
      </button> -->
      <button onclick="demoAI()" class="px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors font-medium">
        示例: AI 渲染（工具模式）
      </button>
      <button onclick="demoAIIncremental()" class="px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition-colors font-medium">
        示例: AI 渲染（增量模式）
      </button>
      <button onclick="clearApp()" class="px-4 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600 transition-colors font-medium">
        清空
      </button>
    </div>

    <!-- 输入区域（初始状态和继续对话状态互斥显示） -->
    <div class="flex gap-2 mb-5" id="input-area">
      <input 
        type="text" 
        id="ai-prompt" 
        placeholder="输入你的需求，例如：创建一个包含标题和段落的文章" 
        class="flex-1 px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
      >
      <button id="generate-btn" onclick="demoAI()" class="px-6 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors font-medium disabled:bg-gray-400 disabled:cursor-not-allowed">
        生成（工具）
      </button>
      <button id="generate-incremental-btn" onclick="demoAIIncremental()" class="px-6 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition-colors font-medium disabled:bg-gray-400 disabled:cursor-not-allowed">
        生成（增量）
      </button>
      <button id="continue-btn" onclick="continueChat()" class="px-6 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors font-medium hidden disabled:bg-gray-400 disabled:cursor-not-allowed">
        发送
      </button>
      <button id="stop-btn" onclick="stopAI()" disabled class="px-6 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600 transition-colors font-medium disabled:bg-gray-400 disabled:cursor-not-allowed">
        停止
      </button>
    </div>

    <!-- 渲染区域 -->
    <div id="app" class="relative flex-1 border-2 border-gray-300 rounded-lg bg-white overflow-y-auto mt-5 shadow-sm"></div>
  </div>

  <!-- 右侧面板 -->
  <div class="w-[500px] flex-shrink-0 flex flex-col gap-5">
    <!-- 模型输出日志 -->
    <div class="flex-1 flex flex-col min-h-0">
      <div class="flex justify-between items-center mb-3">
        <h2 class="text-xl font-semibold text-gray-800">模型输出日志</h2>
        <button onclick="clearLog()" class="px-3 py-1 bg-gray-500 text-white text-sm rounded hover:bg-gray-600 transition-colors">
          清空日志
        </button>
      </div>
      <div id="output-log" class="flex-1 border-2 border-gray-300 p-4 rounded-lg bg-gray-50 overflow-y-auto font-mono text-xs min-h-0"></div>
    </div>
    
    <!-- 渲染指令 -->
    <div class="flex-1 flex flex-col min-h-0">
      <div class="p-4 border-2 border-blue-500 rounded-lg bg-blue-50 flex flex-col flex-1 min-h-0">
        <div class="flex justify-between items-center mb-3">
          <h3 class="text-lg font-semibold text-blue-600">渲染指令</h3>
          <button onclick="clearCommands()" class="px-3 py-1 bg-gray-500 text-white text-sm rounded hover:bg-gray-600 transition-colors">
            清空
          </button>
        </div>
        <div id="render-commands-output" class="flex-1 overflow-y-auto bg-white p-3 rounded border border-gray-300 font-mono text-xs min-h-0"></div>
      </div>
    </div>
  </div>

  <script type="module">
    import { createRenderer } from '../src/renderer.js';
    import { renderWithAI } from './openai-integration.js';
    import { renderWithAIIncremental } from './incremental-openai-integration.js';

    // 创建渲染器
    window.renderer = createRenderer('#app', {
      onToolCall: (result) => {
        console.log('Tool call result:', result);
      },
      onError: (error) => {
        console.error('Error:', error);
      },
    });

    // 示例 1: 基础渲染
    window.demo1 = async function() {
      const toolCalls = [
        {
          name: 'h',
          arguments: JSON.stringify({
            parentId: 'root',
            tagName: 'div',
            props: { id: 'container', className: 'container', style: { padding: '20px', backgroundColor: '#f0f0f0' } }
          })
        },
        {
          name: 'h',
          arguments: JSON.stringify({
            parentId: 'container',
            tagName: 'h1',
            props: { id: 'title' }
          })
        },
        {
          name: 'setText',
          arguments: JSON.stringify({
            elementId: 'title',
            text: '欢迎使用流式 HTML 渲染'
          })
        },
        {
          name: 'h',
          arguments: JSON.stringify({
            parentId: 'container',
            tagName: 'p',
            props: { id: 'content' }
          })
        },
        {
          name: 'setText',
          arguments: JSON.stringify({
            elementId: 'content',
            text: '这是一个演示流式渲染的示例。'
          })
        },
      ];

      // 模拟流式处理
      for (const toolCall of toolCalls) {
        await new Promise(resolve => setTimeout(resolve, 200));
        renderer.executeToolCall(toolCall);
      }
    };

    // 示例 2: 流式文本
    window.demo2 = async function() {
      const toolCalls = [
        {
          name: 'h',
          arguments: JSON.stringify({
            parentId: 'root',
            tagName: 'div',
            props: { id: 'stream-container', style: { padding: '20px' } }
          })
        },
        {
          name: 'h',
          arguments: JSON.stringify({
            parentId: 'stream-container',
            tagName: 'p',
            props: { id: 'stream-text', style: { fontSize: '18px', lineHeight: '1.6' } }
          })
        },
      ];

      // 先创建元素
      for (const toolCall of toolCalls) {
        renderer.executeToolCall(toolCall);
      }

      // 然后流式追加文本
      const text = '这是一个流式文本输出的示例。文字会逐字逐句地显示出来，就像大模型在实时生成内容一样。';
      for (let i = 0; i < text.length; i++) {
        await new Promise(resolve => setTimeout(resolve, 50));
        renderer.executeToolCall({
          name: 'appendText',
          arguments: JSON.stringify({
            elementId: 'stream-text',
            text: text[i]
          })
        });
      }
    };

    // 示例 3: 动态表单
    window.demo3 = async function() {
      const toolCalls = [
        {
          name: 'h',
          arguments: JSON.stringify({
            parentId: 'root',
            tagName: 'form',
            props: { id: 'my-form', style: { padding: '20px', border: '1px solid #ccc', borderRadius: '8px' } }
          })
        },
        {
          name: 'h',
          arguments: JSON.stringify({
            parentId: 'my-form',
            tagName: 'label',
            props: { id: 'name-label' }
          })
        },
        {
          name: 'setText',
          arguments: JSON.stringify({
            elementId: 'name-label',
            text: '姓名: '
          })
        },
        {
          name: 'h',
          arguments: JSON.stringify({
            parentId: 'my-form',
            tagName: 'input',
            props: { 
              id: 'name-input',
              type: 'text',
              placeholder: '请输入姓名',
              style: { padding: '8px', margin: '10px 0', width: '200px' }
            }
          })
        },
        {
          name: 'h',
          arguments: JSON.stringify({
            parentId: 'my-form',
            tagName: 'br',
            props: {}
          })
        },
        {
          name: 'h',
          arguments: JSON.stringify({
            parentId: 'my-form',
            tagName: 'button',
            props: { 
              id: 'submit-btn',
              type: 'button',
              style: { padding: '10px 20px', marginTop: '10px' }
            }
          })
        },
        {
          name: 'setText',
          arguments: JSON.stringify({
            elementId: 'submit-btn',
            text: '提交'
          })
        },
      ];

      // 模拟流式处理
      for (const toolCall of toolCalls) {
        await new Promise(resolve => setTimeout(resolve, 150));
        renderer.executeToolCall(toolCall);
      }
    };

    // 全局变量：保存对话历史和控制器
    window.aiController = null;
    window.conversationHistory = null;
    window.currentRenderer = renderer;
    window.currentIncrementalRenderer = null;
    window.useIncrementalMode = false; // 标记当前使用的模式

    // 示例 4: AI 渲染（批量模式）
    window.demoAI = async function() {
      const promptInput = document.getElementById('ai-prompt');
      const prompt = promptInput.value.trim() || '创建一个包含标题和段落的文章，标题是"AI 的未来"，段落内容是关于人工智能的发展。';
      
      // 如果是新对话，清空之前的内容和渲染指令
      if (!window.conversationHistory) {
        renderer.clear();
        if (typeof clearCommands === 'function') {
          clearCommands();
        }
      }
      
      // 创建中断控制器
      window.aiController = new AbortController();
      const generateBtn = document.getElementById('generate-btn');
      const generateIncrementalBtn = document.getElementById('generate-incremental-btn');
      const continueBtn = document.getElementById('continue-btn');
      const stopBtn = document.getElementById('stop-btn');
      
      // 更新按钮状态：显示生成按钮，隐藏发送按钮
      generateBtn.disabled = true;
      generateIncrementalBtn.disabled = true;
      generateBtn.classList.remove('hidden');
      generateIncrementalBtn.classList.remove('hidden');
      continueBtn.classList.add('hidden');
      stopBtn.disabled = false;
      
      // 更新输入框占位符
      promptInput.placeholder = '输入你的需求，例如：创建一个包含标题和段落的文章';
      
      // 标记使用批量模式
      window.useIncrementalMode = false;
      
      try {
        const result = await renderWithAI(prompt, document.getElementById('app'), {
          onLog: (message, type, data) => {
            if (typeof addLog === 'function') {
              addLog(message, type, data);
            }
          },
          onCommand: (toolCall) => {
            if (typeof addRenderCommand === 'function') {
              addRenderCommand(toolCall);
            }
          },
          messages: window.conversationHistory,
          signal: window.aiController.signal
        });
        
        // 保存对话历史
        window.conversationHistory = result.messages;
        window.currentRenderer = result.renderer;
        
        // 切换到继续对话状态：隐藏生成按钮，显示发送按钮
        generateBtn.classList.add('hidden');
        generateIncrementalBtn.classList.add('hidden');
        continueBtn.classList.remove('hidden');
        continueBtn.disabled = false;
        promptInput.placeholder = '继续输入你的需求...';
        promptInput.focus();
        
      } catch (error) {
        console.error('AI 渲染错误:', error);
        if (typeof addLog === 'function') {
          if (error.message === 'Request aborted by user') {
            addLog('⏹️ 用户中断了请求', 'warning');
          } else {
            addLog(`AI 渲染失败: ${error.message}`, 'error', error);
          }
        }
        if (error.message !== 'Request aborted by user') {
          alert('AI 渲染失败: ' + error.message);
        }
      } finally {
        // 恢复按钮状态
        generateBtn.disabled = false;
        generateIncrementalBtn.disabled = false;
        stopBtn.disabled = true;
      }
    };

    // 停止 AI 渲染
    window.stopAI = function() {
      if (window.aiController) {
        window.aiController.abort();
        window.aiController = null;
        if (typeof addLog === 'function') {
          addLog('⏹️ 正在停止...', 'warning');
        }
      }
    };


    // 示例 5: AI 渲染（增量模式）
    window.demoAIIncremental = async function() {
      const promptInput = document.getElementById('ai-prompt');
      const prompt = promptInput.value.trim() || '创建一个包含标题和段落的文章，标题是"AI 的未来"，段落内容是关于人工智能的发展。';
      
      // 如果是新对话，清空之前的内容和渲染指令
      if (!window.conversationHistory) {
        if (window.currentIncrementalRenderer) {
          window.currentIncrementalRenderer.clear();
        } else {
          renderer.clear();
        }
        if (typeof clearCommands === 'function') {
          clearCommands();
        }
      }
      
      // 创建中断控制器
      window.aiController = new AbortController();
      const generateBtn = document.getElementById('generate-btn');
      const generateIncrementalBtn = document.getElementById('generate-incremental-btn');
      const continueBtn = document.getElementById('continue-btn');
      const stopBtn = document.getElementById('stop-btn');
      
      // 更新按钮状态：显示生成按钮，隐藏发送按钮
      generateBtn.disabled = true;
      generateIncrementalBtn.disabled = true;
      generateBtn.classList.remove('hidden');
      generateIncrementalBtn.classList.remove('hidden');
      continueBtn.classList.add('hidden');
      stopBtn.disabled = false;
      
      // 更新输入框占位符
      promptInput.placeholder = '输入你的需求，例如：创建一个包含标题和段落的文章';
      
      // 标记使用增量模式
      window.useIncrementalMode = true;
      
      try {
        const result = await renderWithAIIncremental(prompt, document.getElementById('app'), {
          onLog: (message, type, data) => {
            if (typeof addLog === 'function') {
              addLog(message, type, data);
            }
          },
          onCommand: (toolCall) => {
            if (typeof addRenderCommand === 'function') {
              addRenderCommand(toolCall);
            }
          },
          messages: window.conversationHistory,
          signal: window.aiController.signal
        });
        
        // 保存对话历史
        window.conversationHistory = result.messages;
        window.currentIncrementalRenderer = result.renderer;
        
        // 切换到继续对话状态：隐藏生成按钮，显示发送按钮
        generateBtn.classList.add('hidden');
        generateIncrementalBtn.classList.add('hidden');
        continueBtn.classList.remove('hidden');
        continueBtn.disabled = false;
        promptInput.placeholder = '继续输入你的需求...';
        promptInput.focus();
        
      } catch (error) {
        console.error('AI 渲染错误:', error);
        if (typeof addLog === 'function') {
          if (error.message === 'Request aborted by user') {
            addLog('⏹️ 用户中断了请求', 'warning');
          } else {
            addLog(`AI 渲染失败: ${error.message}`, 'error', error);
          }
        }
        if (error.message !== 'Request aborted by user') {
          alert('AI 渲染失败: ' + error.message);
        }
      } finally {
        // 恢复按钮状态
        generateBtn.disabled = false;
        generateIncrementalBtn.disabled = false;
        stopBtn.disabled = true;
      }
    };

    // 继续对话（支持两种模式）
    window.continueChat = async function() {
      const promptInput = document.getElementById('ai-prompt');
      const prompt = promptInput.value.trim();
      
      if (!prompt) {
        alert('请输入你的需求');
        return;
      }
      
      if (!window.conversationHistory) {
        alert('没有对话历史，请先开始一个新对话');
        return;
      }
      
      // 清空输入框
      promptInput.value = '';
      
      // 创建中断控制器
      window.aiController = new AbortController();
      const continueBtn = document.getElementById('continue-btn');
      const stopBtn = document.getElementById('stop-btn');
      continueBtn.disabled = true;
      stopBtn.disabled = false;
      
      try {
        // 根据当前模式选择不同的渲染函数
        if (window.useIncrementalMode) {
          const result = await renderWithAIIncremental(prompt, document.getElementById('app'), {
            onLog: (message, type, data) => {
              if (typeof addLog === 'function') {
                addLog(message, type, data);
              }
            },
            onCommand: (toolCall) => {
              if (typeof addRenderCommand === 'function') {
                addRenderCommand(toolCall);
              }
            },
            messages: window.conversationHistory,
            signal: window.aiController.signal,
            renderer: window.currentIncrementalRenderer
          });
          
          // 更新对话历史
          window.conversationHistory = result.messages;
          window.currentIncrementalRenderer = result.renderer;
        } else {
          const result = await renderWithAI(prompt, document.getElementById('app'), {
            onLog: (message, type, data) => {
              if (typeof addLog === 'function') {
                addLog(message, type, data);
              }
            },
            onCommand: (toolCall) => {
              if (typeof addRenderCommand === 'function') {
                addRenderCommand(toolCall);
              }
            },
            messages: window.conversationHistory,
            signal: window.aiController.signal,
            renderer: window.currentRenderer
          });
          
          // 更新对话历史
          window.conversationHistory = result.messages;
          window.currentRenderer = result.renderer;
        }
        
      } catch (error) {
        console.error('继续对话错误:', error);
        if (typeof addLog === 'function') {
          if (error.message === 'Request aborted by user') {
            addLog('⏹️ 用户中断了请求', 'warning');
          } else {
            addLog(`继续对话失败: ${error.message}`, 'error', error);
          }
        }
        if (error.message !== 'Request aborted by user') {
          alert('继续对话失败: ' + error.message);
        }
      } finally {
        continueBtn.disabled = false;
        stopBtn.disabled = true;
        promptInput.focus();
      }
    };

    // 清空应用
    window.clearApp = function() {
      if (window.currentIncrementalRenderer) {
        window.currentIncrementalRenderer.clear();
      } else {
        renderer.clear();
      }
      const promptInput = document.getElementById('ai-prompt');
      promptInput.value = '';
      // 清空对话历史
      window.conversationHistory = null;
      window.currentIncrementalRenderer = null;
      window.useIncrementalMode = false;
      // 重置到初始状态：显示生成按钮，隐藏发送按钮
      const generateBtn = document.getElementById('generate-btn');
      const generateIncrementalBtn = document.getElementById('generate-incremental-btn');
      const continueBtn = document.getElementById('continue-btn');
      generateBtn.classList.remove('hidden');
      generateIncrementalBtn.classList.remove('hidden');
      continueBtn.classList.add('hidden');
      promptInput.placeholder = '输入你的需求，例如：创建一个包含标题和段落的文章';
      // 清空渲染指令
      if (typeof clearCommands === 'function') {
        clearCommands();
      }
      // 如果正在运行，停止它
      if (window.aiController) {
        window.aiController.abort();
        window.aiController = null;
      }
    };

    // 清空日志
    window.clearLog = function() {
      document.getElementById('output-log').innerHTML = '';
    };

    // 清空渲染指令
    window.clearCommands = function() {
      document.getElementById('render-commands-output').innerHTML = '';
    };

    // 添加渲染指令函数
    window.addRenderCommand = function(toolCall) {
      const commandsContainer = document.getElementById('render-commands-output');
      const commandItem = document.createElement('div');
      commandItem.className = 'mb-2 p-2 bg-gray-50 border-l-4 border-blue-500 rounded';
      
      const commandName = document.createElement('div');
      commandName.className = 'font-bold text-blue-600 mb-1';
      commandName.textContent = toolCall.name || '未知';
      
      const commandArgs = document.createElement('div');
      commandArgs.className = 'text-gray-700 whitespace-pre-wrap break-all text-xs';
      
      try {
        let args = toolCall.arguments;
        if (typeof args === 'string') {
          args = JSON.parse(args);
        }
        commandArgs.textContent = JSON.stringify(args, null, 2);
      } catch (e) {
        commandArgs.textContent = String(toolCall.arguments || '');
      }
      
      commandItem.appendChild(commandName);
      commandItem.appendChild(commandArgs);
      commandsContainer.appendChild(commandItem);
      
      // 自动滚动到底部
      commandsContainer.scrollTop = commandsContainer.scrollHeight;
    };

    // 添加日志函数
    window.addLog = function(message, type = 'info', data = null) {
      const logContainer = document.getElementById('output-log');
      const entry = document.createElement('div');
      entry.className = `log-entry ${type} mb-2.5 p-2 border-l-4 border-gray-300 bg-white rounded`;
      
      const time = new Date().toLocaleTimeString();
      entry.innerHTML = `
        <div class="text-gray-500 text-xs mb-1">${time}</div>
        <div class="whitespace-pre-wrap break-all">${escapeHtml(message)}</div>
        ${data ? `<div class="mt-1.5 text-gray-700 max-h-48 overflow-y-auto">${formatData(data)}</div>` : ''}
      `;
      
      logContainer.appendChild(entry);
      logContainer.scrollTop = logContainer.scrollHeight;
    };

    // 转义 HTML
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // 格式化数据
    function formatData(data) {
      try {
        if (typeof data === 'string') {
          return escapeHtml(data);
        }
        return '<pre>' + escapeHtml(JSON.stringify(data, null, 2)) + '</pre>';
      } catch (e) {
        return escapeHtml(String(data));
      }
    }
  </script>
</body>
</html>

